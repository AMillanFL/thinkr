#' @name ublo
#' @aliases ublo_
#' @title Execute some functions inside the dplyr flow
#' @description allow to have a look inside the dplyr flow. see Example.
#' @param dataset A tbl, a data.frame.
#' @param ... a Comma separated list of unquoted function. use ublo_ to do standard evaluation
#' @examples
#' data(iris)
#' if( require(magrittr)){
#'   iris %>% ublo(head,summary) %>% plot
#'   iris %>% ublo_("head","summary") %>% plot
#' }
#' @return the same dataset as input
#' @export
ublo <- function(dataset,...){
  todo<-substitute(list(...))
  eval_todo<-eval(todo)
  for ( j in seq_along(eval_todo)){
    print(eval_todo[[j]](dataset))
  }
  invisible(dataset)
}

#' @export
ublo_ <- function(dataset,...){
  todo<-substitute(list(...))
  eval_todo<-lapply(todo,function(k){eval(parse(text=k))})
  for ( j in seq_along(eval_todo)){
    print(eval_todo[[j]](dataset))
  }
  invisible(dataset)
}

#' @title Execute some functions inside the dplyr flow
#' @description allow to have a look inside the dplyr flow. see Example
#' @param dataset A tbl, a data.frame.
#' @param ... List of function calls, generated by funs, or a character vector of function names.
#' @examples
#' data(iris)
#' if( require(dplyr) ){
#'   iris %>% ublo2(funs(head(.,n=2),summary(.,maxsum=2))) %>% plot
#'   iris %>% ublo2(funs(summary(.,maxsum=2))) %>% plot
#'   #iris %>% ublo2(funs_(dots=c("summary"))) %>% plot
#' }
#' @return the same dataset as input
#' @export
#' @importFrom lazyeval lazy_eval
ublo2 <- function(dataset,...){
  todo<-substitute(list(...))
  eval_todo<-eval(todo)
  .<-dataset # c'est moche de faire ca
  print(lazy_eval(eval_todo[[1]]))
  invisible(dataset)
}


#' @title Execute some functions inside the dplyr flow
#' @description allow to have a look inside the dplyr flow. see Example.
#' @param dataset A tbl, a data.frame.
#' @param funs to be documented
#' @param ... List of function calls, generated by funs, or a character vector of function names.
#' @examples
#' data(iris)
#' if( require(dplyr) ){
#'   iris %>% ublo3(funs(summary(.))) %>% plot
#'   iris %>% ublo3(funs(summary(.),head(.))) %>% plot
#'   iris %>% ublo3(funs_(c("summary"))) %>% plot
#'   iris %>% ublo3(funs_(c("summary","head"))) %>% plot
#' }
#' @return the same dataset as input
#' @export
ublo3 <- function(dataset,funs,...){
   # browser()
  # print(lazy_eval(funs)) # ne fonctionne pas si funs_
  for ( j in 1:length(funs)){
    print(eval(funs[[j]]$expr,envir = parent.frame()))
      }




  invisible(dataset)
}

# borrowed from e.g. dplyr
dots <- function (...){
    eval(substitute(alist(...)))
}

#' peep the pipeline
#'
#' peep some data at one step of a pipeline.
#'
#' @param data some data
#' @param \dots function names or expressions that use \code{.} as a
#'        placeholder for the data
#' @param printer which function use to print
#' @param verbose TRUE to include what is printed
#'
#' @examples
#' if( require(magrittr) ){
#'   # just symbols
#'   iris %>% peep(head,tail) %>% summary
#'   # expressions with .
#'   iris %>% peep(head(., n=2),tail(., n=3) ) %>% summary
#'   # or both
#'   iris %>% peep(head,tail(., n=3) ) %>% summary
#'   # use verbose to see what happens
#'   iris %>% peep(head,tail(., n=3), verbose = TRUE) %>% summary
#' }
#' @return the input data
#' @importFrom lazyeval interp
#' @export
peep <- function(data, ... , printer = print, verbose = FALSE){
  dots <- dots(...)
  for( expr in dots){
    # first deal with symbols, e.g. peep(head,tail) --> peep( head(.), tail(.) )
    if( typeof(expr) == "symbol"){
      expr <- interp( quote(fun(.)) , fun = expr)
    }

    # print what we are peeping
    if( verbose ){
      message(deparse(substitute(expr)))
    }

    # replace . with the data
    expr <- interp(expr, .values = list( . = data) )

    # add the print call
    expr <- interp( quote(printer(expr)), .values = list(expr = expr) )

    # eval
    eval(expr)
  }
  data
}
